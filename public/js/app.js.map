{"version":3,"sources":["hammer-time.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/* Hammer-time - v0.3.0\n * http://github.com/hammerjs/hammer-time\n *\n * Copyright Alexander Schmitz and other contributors\n * Released under the MIT license\n *\n * Expiramental fastclick based on a partial polyfill of\n * touch-action: none; CSS property\n */\n\n( function() {\n\n\t// Detect support for necessary features;\n\tvar MO = window.MutationObserver || window.WebKitMutationObserver;\n\tvar touchevents = ( \"ontouchstart\" in window ) ||\n\t                  ( window.DocumentTouch && document instanceof DocumentTouch );\n\tvar nativeTouchAction = document.documentElement.style[ \"touch-action\" ] !== undefined ||\n\t\t\t                            document.documentElement.style[ \"-ms-touch-action\" ];\n\n// If there is native touch action bail the hammer has already dropped\nif ( nativeTouchAction || !touchevents || !MO ) {\n\treturn;\n}\n\n//Check if a global Hammer object already exists\nwindow.Hammer = window.Hammer || {};\n\n// We need to save the last touch start in iOS 8 if it is more then 150ms\n// it will trigger native fast click which cant ne stoped even with all the might\n// of thors hammer and a return false\nvar touchMatchNone = /touch-action[:][\\s]*(none)[^;'\"]*/;\nvar touchMatchManipulation = /touch-action[:][\\s]*(manipulation)[^;'\"]*/;\nvar touchMatch = /touch-action/;\nvar timeTouch = /(iP(ad|hone|od))/.test( navigator.userAgent ) && ( \"indexedDB\" in window || !!window.performance );\n\nwindow.Hammer.time = {\n\n\t// Check if an element has touch action none in its style attribute and thusly should\n\t// be hammered upon\n\tgetTouchAction: function( element ) {\n\t\treturn this.checkStyleString( element.getAttribute( \"style\" ) );\n\t},\n\tcheckStyleString: function( style ) {\n\t\tif ( !touchMatch.test( style ) ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif ( touchMatchNone.test( style ) ) {\n\t\t\treturn \"none\";\n\t\t}\n\t\tif ( touchMatchManipulation.test( style ) ) {\n\t\t\treturn \"manipulation\";\n\t\t}\n\t\treturn true;\n\t},\n\tshouldHammer: function( e ) {\n\t\tvar parentAction = e.target.hasParent;\n\t\treturn ( parentAction && ( !timeTouch || Date.now() - e.target.lastStart < 125 ) ) ?\n\t\t\t\tparentAction : false;\n\t},\n\ttouchHandler: function( e ) {\n\t\tvar hammerType = this.shouldHammer( e );\n\n\t\t// Check both if we should trigger fast click and the time to avoid a double trigger with\n\t\t// native fast click\n\t\tif ( hammerType === \"none\" ) {\n\t\t\tthis.dropHammer( e );\n\t\t} else if ( hammerType === \"manipulation\" ) {\n\t\t\tvar pos = e.target.getBoundingClientRect();\n\t\t\tvar scrolled = pos.top !== this.pos.top || pos.left !== this.pos.left;\n\t\t\t!scrolled && this.dropHammer( e );\n\t\t}\n\t\tthis.scrolled = false;\n\t\tdelete e.target.lastStart;\n\t\tdelete e.target.hasParent;\n\t},\n\tdropHammer: function( e ) {\n\t\tif ( e.type === \"touchend\" ) {\n\t\t\te.target.focus();\n\n\t\t\t// Wait for next tic so events fire in proper order\n\t\t\tsetTimeout( function() {\n\t\t\t\te.target.click();\n\t\t\t}, 0 );\n\t\t}\n\n\t\t// Prevent the click which will come after this otherwise but with a 300ms delay\n\t\te.preventDefault();\n\t},\n\ttouchStart: function( e ) {\n\t\tthis.pos = e.target.getBoundingClientRect();\n\t\te.target.hasParent = this.hasParent( e.target );\n\t\tif ( timeTouch && e.target.hasParent ) {\n\t\t\te.target.lastStart = Date.now();\n\t\t}\n\t},\n\tstyleWatcher: function( mutations ) {\n\t\tmutations.forEach( this.styleUpdater, this );\n\t},\n\tstyleUpdater: function( mutation ) {\n\n\t\t// We just caused this update bail\n\t\tif ( mutation.target.updateNext ) {\n\t\t\tmutation.target.updateNext = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar touchAction = this.getTouchAction( mutation.target );\n\n\t\tif ( touchAction ) {\n\t\t\tif ( touchAction !== \"none\" ) {\n\t\t\t\tmutation.target.hadTouchNone = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif ( !touchAction &&\n\t\t\t\t(\n\t\t\t\t\t( mutation.oldValue && this.checkStyleString( mutation.oldValue ) ) ||\n\t\t\t\t\tmutation.target.hadTouchNone\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t// We save this because during animations which update the style in quick succession\n\t\t\t// style tag can update quicker then the mutation observer fires so we lose the oldValue\n\t\t\t// property which contains our refrence to the original which contained touch-action.\n\t\t\tmutation.target.hadTouchNone = true;\n\n\t\t\t// Save the fact that we caused the next update\n\t\t\tmutation.target.updateNext = false;\n\n\t\t\t// Add touch action back to the style attribute\n\t\t\tmutation.target\n\t\t\t\t.setAttribute( \"style\",\n\t\t\t\t\tmutation.target.getAttribute( \"style\" ) + \" touch-action: none;\"\n\t\t\t\t);\n\n\t\t}\n\t},\n\thasParent: function( node ) {\n\t\tvar touchAction;\n\t\tfor ( var cur = node; cur && cur.parentNode; cur = cur.parentNode ) {\n\t\t\ttouchAction = this.getTouchAction( cur );\n\t\t\tif ( touchAction ) {\n\t\t\t\treturn touchAction;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tinstallStartEvents: function() {\n\t\tdocument.addEventListener( \"touchstart\", this.touchStart.bind( this ) );\n\t\tdocument.addEventListener( \"mousedown\", this.touchStart.bind( this ) );\n\t},\n\tinstallEndEvents: function() {\n\t\tdocument.addEventListener( \"touchend\", this.touchHandler.bind( this ), true );\n\t\tdocument.addEventListener( \"mouseup\", this.touchHandler.bind( this ), true );\n\t},\n\tinstallObserver: function() {\n\n\t\t// We need to observe changes to style attributes because if something updates the style\n\t\t// attribute it will remove the touch-action property because browsers santitize the style\n\t\t// attribute when its properties are updated.\n\t\tthis.observer = new MO( this.styleWatcher.bind( this ) ).observe( document, {\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: [ \"style\" ]\n\t\t} );\n\t},\n\tinstall: function() {\n\t\tthis.installEndEvents();\n\t\tthis.installStartEvents();\n\t\tthis.installObserver();\n\t}\n};\n\nwindow.Hammer.time.install();\n\n} )();\n","var app = app || {};\n\n(function() {\n\n    \"use strict\";\n\n    app.userIcon = document.getElementById('user-icon');\n    app.topNavdropDownMenu = document.getElementsByClassName('dropdown')[0];\n    app.topNavdropDownMenu.style.display = 'none';\n    app.bindEventOndocument = function() {\n        document.onclick = function(event) {\n            if(event.target != app.userIcon) {\n                app.topNavdropDownMenu.style.display = 'none';\n            }\n        };\n    },\n    app.unbindEventOndocument = function() {\n        document.onclick = function() {\n            return false;\n        };\n    };\n\n\n    app.userIcon.addEventListener(\"click\", function() {\n        if(app.topNavdropDownMenu.style.display == 'none') {\n            app.topNavdropDownMenu.style.display = 'block';\n            app.bindEventOndocument();\n        } else {\n            app.topNavdropDownMenu.style.display = 'none';\n            app.unbindEventOndocument();\n        }\n    });\n\n})();\n\n// $(document).ready(function(){\n//     $('[data-toggle=\"help-popover\"]').popover({ trigger: 'hover', placement: 'bottom', html: true });\n\n//     /*  TAB MENU */\n//     // for bootstrap 3 use 'shown.bs.tab', for bootstrap 2 use 'shown' in the next line\n//     $('a[data-toggle=\"tab\"]').on('shown.bs.tab', function (e) {\n//         // save the latest tab; use cookies if you like 'em better:\n//         localStorage.setItem('lastTab', $(this).attr('href'));\n//     });\n\n//     // go to the latest tab, if it exists:\n//     var lastTab = localStorage.getItem('lastTab');\n//     if (lastTab) {\n//         $('[href=\"' + lastTab + '\"]').tab('show');\n//     }\n\n//     // $('[data-toggle=\"tooltip\"]').tooltip();\n//     $(document).on('mouseenter','[data-toggle=tooltip]', function(){\n//         $(this).tooltip('show');\n//     });\n\n//     $(document).on('mouseleave','[data-toggle=tooltip]', function(){\n//         $(this).tooltip('hide');\n//     });\n// });\n"],"sourceRoot":"/source/"}